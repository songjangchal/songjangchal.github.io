#+title: 一些小技巧

* 计算机术语
** agent, proxy, gatewayn
** 通讯与通信有什么区别
*** 知乎
https://www.zhihu.com/question/19748672

#+BEGIN_EXAMPLE

大陆叫信，短信，电信，通信。
港澳台叫讯，简讯，电讯，通讯。
哪有上面人扯得那么深奥。
#+END_EXAMPLE 


#+BEGIN_EXAMPLE

别太咬文嚼字了，港澳跟内地的叫法区别罢了
我在澳门读的资讯科技学院，内地叫信息技术学院，我的专业通讯工程，内地叫通信工程
通讯（港澳）==通信（内地）；
资讯（港澳）==信息（内地）；
#+END_EXAMPLE


#+BEGIN_EXAMPLE
我也有这个疑惑，举个例子：
中国移动通信集团有限公司，为什么不叫中国移动通讯集团有限公司？
中兴通讯股份有限公司，为什么不叫中兴通信股份有限公司？
所以我觉得 
@小欧
的解释更合理和容易理解一些。


小欧
我只知道自己无知。

通信是人与人之间的信息互通；如：我都很久没跟我那老姨父通过信了。

通讯是设备与环境之间的信号互通；如：我们西部地区的通讯很不发达，常常不在服务区。

怕就怕一个二猛子突然上来再问一个：

「信息」和「信号」之间有什么区别？
擦，这就糗大了。
#+END_EXAMPLE

#+BEGIN_EXAMPLE
 正好约6小时前看到王兴在饭否发了这么一条：
王兴出乎意料，当我想搞明白「通信」和「通讯」这两个词的差别时，给我最满意答案的不是百度知道，也不是各种百科，甚至也不是quora/知乎，而是阿里巴巴论坛里某个帖的第五楼。当然，是通过google找到的。通信与通讯的区别是什么?_商人论坛约 6 小时前 通过 iPhone版

链接的具体解释如下：
王海啸 2007-03-22 22:11  5楼
《现代汉语词典第 5 版说明》强调：“全面正确地执行国家的语言文字规范和科技术语规范是本书的重要原则。”新版《现代汉语词典》在“通信”“通讯”等词条的处理上，体现了执行科技术语规范的编写原则。

旧版《现汉》(《现代汉语词典》第 3 版、第 4 版) “通信”“通讯”词条的释义：
【通信】用书信互通消息, 反映情况等：～处|我们几年前曾经通过信。
【通信】利用电波、光波等信号传送文字、图像等：数字～通讯
【通讯】①利用电讯设备传递消息:～班|无线电～。②详实而生动地报道客观事物或典型人物的文章。

新版《现汉》(《现代汉语词典》第 5 版) “通信”“通讯”词条的释义：
【通信】①用书信互通消息, 反映情况等：～处|我们几年前曾经通过信。②利用电波、光波等信号传送文字、图像等。根据信号方式的不同, 可分为模拟通信和数字通信。旧称通讯。
【通讯】①通信②的旧称。②翔实而生动地报道客观事物或典型人物的文章。

经比较可看出，《现代汉语词典》第 5 版作了如下调整：
1.将旧版《现汉》的两个【通信】词条合为一个词条，并在义项②的释义中增加了“根据信号方式的不同，可分为模拟通信和数字通信。旧称通讯”的说明。
2.将旧版《现汉》的【通讯】词条的义项①“利用电讯设备传递消息:～班|无线电～”删去，改为“通信②的旧称”。
这样的调整，是为了说明“通信”与“通讯”各有分工，语义不同，不再通用。
在“利用电波、光波等信号传送文字、图像等”这一意义上，须用“通信”，而不用“通讯”。与之相关的词语有“通信兵”“通信卫星”“通信工程” “通信技术” “通信系统”“无线电通信”等。
“通讯”则只用于与新闻报道相关的词语，如“通讯社”“通讯网”“通讯员”等。
此外，与“通信”和“通讯”相应，“电信”和“电讯”也有分工：“电信”指“利用电话、电报或无线电设备等传送信息的通信方式”，不写作“电讯”；“电讯”指“用电话、电报或无线电设备等传播的消息”，不写作“电信”。

王海啸 2007-03-22 22:11 6楼
通讯和通信的区别：
1、二者强调的重点不同
通信强调的是结果，其结果是使交流的各方清楚某事，而通讯强调的是过程，怎样去传递。比如说到移动通讯，表示那是一项技术，而移动通信，表示的是一项服务，因此，中国移动取名为“中国移动通信”，表示他是帮助人们沟通的，如果改成“中国移动通讯”，那就成了和中兴、华为等一样的提供技术的公司。
2、二者对接收者的有用性不同
内容在通信和通讯的时候都是有载体的，可能是实体符号或者调制信号。通信的时候，通信的接收方一定很清楚怎样从内容里得到传递的信息，而通讯则不是。比如A、B、C和D在同一个communication域里，A往外发信号，B、C和D都能收到，此时我们说A和C在通讯，A和D在通讯，A和B在通讯。可能A只想把内容传送给B而不想让C和D知道，他会把内容加密，而把密钥只交给B，此时B就可以根据密钥拿到A想传递的内容，而C和D就不行，此时我们可以说A和B在通信，而A和C、A和D仍然只是在通讯。
作为一名厌恶论坛的人，最好的东西都在论坛BBS里是反人类的。
#+END_EXAMPLE
*** baidu文库
https://wenku.baidu.com/view/61bb06b465ce0508763213c0.html

#+BEGIN_EXAMPLE

通讯和通信的区别：

1、二者强调的重点不同

通信强调的是结果，其结果是使交流的各方清楚某事，而通讯强调的是过程，怎样去传递。比如说到移动通讯，表示那是一项技术，而移动通信，表示的是一项服务，因此，中国移动取名为“中国移动通信”，表示他是帮助人们沟通的，如果改成“中国移动通讯”，那就成了和中兴、华为等一样的提供技术的公司。

2、二者对接收者的有用性不同

内容在通信和通讯的时候都是有载体的，可能是实体符号或者调制信号。通信的时候，通信的接收方一定很清楚怎样从内容里得到传递的信息，而通讯则不是。比如A、B、C和D在同一个communication域里，A往外发信号，B、C和D都能收到，此时我们说A和C在通讯，A和D在通讯，A和B在通讯。可能A只想把内容传送给B而不想让C和D知道，他会把内容加密，而把密钥只交给B，此时B就可以根据密钥拿到A想传递的内容，而C和D就不行，此时我们可以说A和B在通信，而A和C、A和D仍然只是在通讯。

通信和通讯有什么区别?

1． 通讯和通信

目前，这两个词的使用频率相当高，但词义范围如何界定，并未明确统一。

传统意义上的“通讯”主要指电话、电报、电传。通讯的“讯”指消息（Message）,媒体讯息通过通讯网络从一端传递到另外一端。媒体讯息的内容主要是话音、文字、图片和视频图像。其网络的构成主要由电子设备系统和无线电系统构成，传输和处理的信号是模拟的。所以，“通讯”一词应特指采用电报、电话等媒体传输系统实现上述媒体信息传输的过程。

“通信”仅指数据通信，即通过计算机网络系统和数据通信系统实现数据的端到端传输。通信的“信”指的是信息（Information）,信息的载体是二进制的数据。数据则是可以用来表达传统媒体形式的信息，如声音、图像、动画等。

由于旧的“通讯”系统早已实现了数字化、计算机网络化改造，因此可以认为目前的数据通信系统已涵盖了过去的“通讯”系统的功能。按照这个结论，目前应多使用“通信”一词表达互联网间与局域网内的数据传输，尽量少用或不用“通讯”一词，以免引起概念上的误解。

2． 节点和结点，互联和互连

在技术文章中经常能见到“网络节点”和“网络结点”，还有“互联”和“互连”的提法，它们之间有明确的界定吗？其实，这是个纯粹的语文问题，与技术无关。即使出现了混用，也不至于产生歧义，所以这些词不做任何区分，都可以使用。

3． 协议和标准

网上有不同的协议或标准，“协议”和“标准”的概念相似，但又有所区别。协议（Protocol）是分层

的，就低层而言指通信的各方共同遵守的约定；就高层而言，是对网络应用、管理方面的约定。所以协议的本质就是约定，而且是正式的约定，如IP就是OSI/RM的第三层协议。

而标准的范围更广，它不仅包括已经成文的约定,也包含网络上所有统一执行的规则。所以有时把标准称为规范或规则。比如，IEEE 802.3u是电气电子工程师协会制定的快速以太网标准，同时也可以认为它是100M以太网的一大类协议集；Category (CAT3 、CAT5)是EIA/TIA两个组织为非屏蔽双绞线制定的线类标准，它只能被称为标准，不能叫做协议。

二、同一词语有不同的含义

1．带宽

在网络技术中，不同的应用场合,“带宽”有不同的含义。一种指网络的频率带宽—频带宽度，即网络信号的最大频率与最小频率之差，单位是赫兹;另一种则指局域网的最大传输速率，代表了LAN的数据传输能力，单位是bps。

2．速率

“通信速率”通常分为两种:一种是单位时间内传输的比特数，也叫比特速率、数据传输速率、数据率或简称速率;另一种是单位时间内传输的码元数，也叫码元速率、调制速率、波特速率或简称波特率（Baud Rate）。比特速率值可以和波特速率值相同，也可以不同。例如，对Modem而言,它在运行中的比特速率值远大于波特速率值。

3．媒体

“媒体”(Media)是经常出现的一个词汇，可以理解成用来连结两个或多个事物的中介物，在不同应用场合也被称为传媒、媒介、介质、界面等，但意义都有所不同。

当用于公众信息传播领域，“媒体”称为传媒，像广播、电视、报刊、杂志、网站等，都属于传媒。

当用于计算机信息处理技术上，“媒体”被称为媒体信息。通常指语音、文字、图形图像、动画等多种媒体，即多媒体。

当用于网络和通信技术，则被称为媒体介质、通信媒体、传输介质。我们所熟知的电缆、光缆、无线电、微波等，就属于这一类。

此外，在软件应用领域，把通过显示器向用户输出的那部分媒体信息称为软件的用户界面（UI）。 


#+END_EXAMPLE


* 代替__FILE__宏只显示文件名
  [[https://stackoverflow.com/questions/8487986/file-macro-shows-full-path][参考]]

  在默认的情况下，__FILE__ 被替换成文件的完整路径名，
  如
#+BEGIN_SRC 
    gcc -o app/src/module/proxy.c
#+END_SRC

    __FILE__ 值为 app/src/module/proxy.c
 
  但如果在module目录下执行
#+BEGIN_SRC 
    gcc -o proxy.c
#+END_SRC
    __FILE__ 值为 proxy.c

    在cmake ,scons等编译系统下，log长度就会很长，而我们只希望保留文件名即可

** 在运行时去掉

#+BEGIN_SRC 
#define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
#+END_SRC


在使用时就用__FILENAME__代替__FILE__

** 在预编译去掉 
*** 在makefile中

自己写的例子

c文件

#+BEGIN_SRC  c

#define BASIC_TRACE(level, format, ...)                                  \
    do{                                                                 \
        if(level <= 5){                                      \
            printf("%s(%d): "format"\n", __FILENAME__, __LINE__, ##__VA_ARGS__); \
        }                                                               \
    }while(0)




#include <stdio.h>
#include <string.h>

void main(void){

    BASIC_TRACE(1, "etette");
}


#+END_SRC


makefile 

#+BEGIN_SRC makefile

all: test
clean:
	rm -f test.o test

test : test.c
	gcc $< -D__FILENAME__=\"$(notdir $<)\" -o $@

#+END_SRC



进一步可以放在CFLAGS里

#+BEGIN_SRC makefile
all: test

clean:
	rm -f test.o test

CFLAGS = -D__FILENAME__=\"$(notdir $(abspath $<))\"
#CFLAGS = -D__FILENAME__=\"$(notdir $<)\"

test : test.c
	gcc $< ${CFLAGS} -o $@
#+END_SRC


这里用到了make的notdir函数，作用是去掉路径部分.
abspath不是必须的，只是为了说明notdir函数
*** 在scons中
scons中可以设置编译的命令行，$CCCOM,
以在rt-thread项目为例，
在bsp/stm32f20x/SConstruct文件中，

#+BEGIN_SRC python
if rtconfig.PLATFORM == 'gcc':
   	env.Replace(CCCOM = ['basename $SOURCES | xargs -i{} $CC -o $TARGET -c -D__FILENAME__=\\\"{}\\\" $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES'])
#+END_SRC

先用basename 命令去除多余部分，然后传给$CC， 定义一个宏。
注意这是用的是两次转义操作，因为要在python和bash各转一次。

*** cmake
If you are using CMAKE with GNU compiler this global define works fine
#+BEGIN_SRC 
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__MY_FILE__='\"$(notdir $(abspath $<))\"'")
#+END_SRC

* debug shared library on linux
  现象：
     动态库更改后，马上运行执行程序，更改的动态库不会加载，
     估计是系统为了加快程序启动，没有删除原来的动态库，当发现原来的动态库文件还在，就用缓存中的动态库文件了。
  - 先把library 删除
  - 再把执行程序执行一次，报错，这时系统会把动态库删除
  - 再次生成动态库，库能正确加载

* xsde 调试经验
  - 用内存区域调用解析接口时，不要包含字符结尾 '0'
如
#+BEGIN_SRC c++
unsigned char net_element[] = R"(<railML>
    <functionalInfrastructure> <!--功能设施 -->
      <tracks>  <!--轨道定义 -->
      </tracks>
      <speeds>  <!--速度表 -->
      </speeds>
      <signals> <!--校正点 -->
      </signals>
    </functionalInfrastructure>        
  </infrastructure>
</rail>)";
    Rail rail;
    int rc = rail.ReadXml(net_element, sizeof(net_element) - 1);

#+END_SRC

长度是sizeof(net_element) - 1)时， 运行正确，而改成

#+BEGIN_EXAMPLE
sizeof(net_element)
#+END_EXAMPLE

时，运行时会出现如下错误

#+BEGIN_EXAMPLE
not well-formed (invalid token)
#+END_EXAMPLE


* zeroconf
  http://www.zeroconf.org/
* c++ 
** c++中小数的比较

 使用c++标准函数
 | 函数名              | 代替 |
 | isgreater(a,b)      | >    |
 | isless(a,b)         | <    |
 | isgreaterequal(a,b) | >=   |
 | islessequal(a,b)    | <=   |
 | islessgreater(a,b)  | !=   |

  **在catch里测试 islessgreater 不起作用， 所以不用这个函数作相等判断情况.**

 #+BEGIN_SRC c++
 isgreater(a,b)
 isless(a,b)
 isgreaterequal(a,b)
 islessequal(a,b)
 islessgreater(a,b)

 a,b可以为float, double, long double类型

 #+END_SRC

 http://www.cplusplus.com/reference/limits/numeric_limits/
 #+BEGIN_SRC c++ 
 std::numeric_limits<double>::epsilon()
 #+END_SRC

*** https://stackoverflow.com/questions/17333/what-is-the-most-effective-way-for-float-and-double-comparison


 #+BEGIN_VERSE

 Be extremely careful using any of the other suggestions. It all depends on context.

 I have spent a long time tracing a bugs in a system that presumed a==b if |a-b|<epsilon. The underlying problems were:

     The implicit presumption in an algorithm that if a==b and b==c then a==c.

     Using the same epsilon for lines measured in inches and lines measured in mils (.001 inch). That is a==b but 1000a!=1000b. (This is why AlmostEqual2sComplement asks for the epsilon or max ULPS).

     The use of the same epsilon for both the cosine of angles and the length of lines!

     Using such a compare function to sort items in a collection. (In this case using the builtin C++ operator == for doubles produced correct results.)

 Like I said: it all depends on context and the expected size of a and b.

 BTW, std::numeric_limits<double>::epsilon() is the "machine epsilon". It is the difference between 1.0 and the next value representable by a double. I guess that it could be used in the compare function but only if the expected values are less than 1. (This is in response to @cdv's answer...)

 Also, if you basically have int arithmetic in doubles (here we use doubles to hold int values in certain cases) your arithmetic will be correct. For example 4.0/2.0 will be the same as 1.0+1.0. This is as long as you do not do things that result in fractions (4.0/3.0) or do not go outside of the size of an int

 #+END_VERSE


 #+BEGIN_VERSE



 Comparing floating point numbers for depends on the context. Since even changing the order of operations can produce different results, it is important to know how "equal" you want the numbers to be.

 Comparing floating point numbers by Bruce Dawson is a good place to start when looking at floating point comparison.

 The following definitions are from The art of computer programming by Knuth:

 bool approximatelyEqual(float a, float b, float epsilon)
 {
     return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 bool essentiallyEqual(float a, float b, float epsilon)
 {
     return fabs(a - b) <= ( (fabs(a) > fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 bool definitelyGreaterThan(float a, float b, float epsilon)
 {
     return (a - b) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 bool definitelyLessThan(float a, float b, float epsilon)
 {
     return (b - a) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
 }

 Of course, choosing epsilon depends on the context, and determines how equal you want the numbers to be.

 Another method of comparing floating point numbers is to look at the ULP (units in last place) of the numbers. While not dealing specifically with comparisons, the paper What every computer scientist should know about floating point numbers is a good resource for understanding how floating point works and what the pitfalls are, including what ULP is.


 #+END_VERSE



*** 

 #+BEGIN_SRC c++ 
 // Test whether two float or double numbers are equal.
 // ulp: units in the last place.
 template <typename T>
 typename std::enable_if<!std::numeric_limits<T>::is_integer, bool>::type
 IsAlmostEqual(T x, T y, int ulp = 2)
 {
     // the machine epsilon has to be scaled to the magnitude of the values used
     // and multiplied by the desired precision in ULPs (units in the last place)
     return std::fabs(x - y) < std::numeric_limits<T>::epsilon() * std::fabs(x + y) * ulp
            // unless the result is subnormal
            || std::fabs(x - y) < std::numeric_limits<T>::min();
 }

 #+END_SRC
** c++ lib 
*** 
 http://en.cppreference.com/w/cpp/links/libs

 A list of open source C++ libraries
 < cpp‎ | links

 The objective of this page is to build a comprehensive list of open source C++ libraries, so that when one needs an implementation of particular functionality, one needn't to waste time searching on Google.

 If you know a library that might be useful to others, please add a link to it here. There are no restrictions on what can be included except that the source of the library must be readily available to download.

 The page is provided 'as is' - with the hope of being useful, but without any warranties. Outdated, misleading or wrong links might appear here. If you've noticed one of these, it would be great if you fixed the error.
 Generic

     Boost -  large collection of generic libraries (Boost License)
     BDE -  The BDE Development Environment from Bloomberg L.P. (Apache License)
     Dlib -  networking, threads, graphical interfaces, data structures, linear algebra, machine learning, XML and text parsing, numerical optimization, Bayesian nets, and numerous other tasks (Boost License)
     JUCE -  An extensive, mature, cross-platform C++ toolkit (GPL License)
     Loki -  design patterns
     Reason -  xml, xpath, regex, threads, sockets, http, sql, date-time, streams, encoding and decoding, filesystem, compression (GPL License)
     Yomm11 -  Open multi-methods for C++11 (Boost License)
     Folly -  Facebook Open-source LibrarY. Library of C++11 components designed with practicality and efficiency in mind.
     cxxomfort - Backports of C++ features (C++11 to C++03 and C++1y proposals to C++11/C++03).
     libsourcey -  Cross-platform C++11 library for high speed networking and media encoding. HTTP, WebSockets, TURN, STUN, Symple and more...
     OnPosix -  C++ library providing several abstractions (e.g., threading, networking, logging, IPC, etc.) on POSIX platforms.
     Ultimate++ -  Cross-platform rapid application development framework
     CAF - The C++ Actor Framework (CAF) is an open source C++11 actor model implementation featuring lightweight & fast actor implementations, pattern matching for messages, network transparent messaging, and more (BSD License).
     wdl-AmirFJ - a modified version of WDL-OL with some improvements.
     cpp-mmf - A C++98 library that encapsulates memory-mapped-files for POSIX or Windows
     CommonPP - Multi-purpose library with a strong emphasis on getting metrics out of a project. (BSD)
     Better Enums - Reflective enums (enum to string, iteration, etc.) with constexpr support. (BSD)
     Smart Enum - "to_string", "from_string" and more for your enums. (Boost License)
     nytl - C++11 header-only template library for maths, functions (callbacks) and general utility.
     SaferCPlusPlus -  SaferCPlusPlus - Safe compatible substitutes for unsafe C++ primitives, including pointers, int and std::vector. (Boost License) 

 Communication

     C++ RESTful framework -  C++ micro-framework designed to be embedded into a wide range of applications.
     C++ REST SDK - asynchronous HTTP client and listener, asynchronous Stream, URI, JSON
     cpr - a modern C++ HTTP requests library
     cpp-netlib - cpp-netlib: The C++ Network Library
     Boost.Asio - asynchronous and synchronous networking, timers, serial I/O
     gsoap -  C/C++ development toolkit for XML data bindings, fast WSDL/SOAP/XML Web services, WS-Security, JSON/XML-RPC RESTful services
     POCO -  networking: encryption, HTTP; Zip files
     ACE -  asynchronous networking, event demultiplexing, messaging, CORBA
     wvstreams
     Unicomm -  asynchronous networking, high-level TCP communication framework
     restful_mapper - ORM for consuming RESTful JSON APIs in C++
     zeromq -  fast message queue
     curlpp -  C++ wrapper for CURL library
     Apache Thrift -  The Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.
     libashttp -  asynchronous HTTP client library
     Simple C++ REST library -  Very simple and self documenting library for creating a REST API in your c++ application
     libtins - Network packet crafting and sniffing library
     HTTPP - Simple, production ready HTTP server built on top of Boost and a client built on top of libcurl. (BSD) 

 Graphic user interface

     FLTK
     nana[doc] - GUI programming in modern C++ style (Boost License)
     WxWidgets[src][doc]
     OWLNext - Modern update to OWL for writing GUI applications in standard C++ on Windows
     tiny file dialogs -  a single C C++ cross-platform file (no init, no main loop, 6 modal function calls) 

 GTK+

     glibmm
     gtkmm
     goocanvasmm
     libglademm
     libgnomecanvasmm
     webkitgtk
     flowcanvas
     evince 

 Qt

     Qt[src][doc]
     qwtplot3d
     qwt5
     libdbusmenu-qt 

 General Multimedia

     SFML (Simple and Fast Multimedia Library)
     SDL (Simple DirectMedia Layer) -  cross-platform, low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D (zlib license)
     Cinder
     openFrameworks 

 Graphics

     cairomm
     nux
     pangomm
     gegl
     stb 

 Plotting

     plotutils 

 Formats

     libraw
     openexr
     qimageblitz
     imagemagick
     djvulibre
     poppler
     SVG++ 

 Audio

     soundtouch 

 Fingerprinting

     chromaprint
     libofa
     libmusicbrainz 

 Formats

     audiofile
     flac 

 Tagging

     id3lib
     taglib 

 CD

     libkcompactdisc 

 Image Processing

     opencv 

 Video

     crystalhd
     mjpegtools
     libmatroska
     libVLC
     gstreamermm 

 3D Graphics

     bgfx Cross-platform, graphics API agnostic, "Bring Your Own Engine/Framework" style rendering library.
     Ogre3D
     OpenGL
     GLEW OpenGL function loading
     GLFW OpenGL window manager
     GLM Header only C++ mathematics library for rendering
     assimp 3D model loading
     VTK
     Magnum C++11 and OpenGL/GLES/WebGL graphics engine
     Irrlicht
     Horde3D 


 Game Engine Architecture

     EntityX
     Anax 


 Internationalization

     IBM ICU
     gettext 

 Math

     alglib
     ArrayFire High Performance Computation Library
     GNU MP bignum C++ interface
     Boost.Multiprecision
     Boost.Math.Special Functions and Statistical Distributions
     Boost.Random
     NTL - A Library for doing Number Theory
     cpp-measures - A header-only C++11 library to handle physical measures
     G+Smo cross-platform library for isogeometric analysis 

 Linear algebra

     Boost.uBLAS
     Eigen
     Armadillo
     Blitz++
     IT++
     Dlib - linear algebra tools 

 Graph theory

     Boost.Graph
     LEMON
     OGDF - Open Graph Drawing Framework
     NGraph - a simple (Network) Graph library in C++ 

 Class Library for Numbers

     cln 

 Machine Learning

     liblinear
     Dlib - machine learning tools
     MLPACK - machine learning package
     Shogun - large scale machine learning toolbox 

 Computational geometry

     CGAL - Computational geometry algorithms library
     Wykobi - Computational geometry library
     PCL - Point Cloud library 

 Financial Calculations

     QuantLib - Quantitative finance library 

 Concurrency

     Intel TBB
     OpenMP
     RaftLib C++ stream like concurrent actors
     Thrust STL-like algorithms and data-structures for CUDA
     ViennaCL Linear algebra and algorithms with OpenMP, CUDA, and OpenCL backends
     VexCL C++ expression templates library for OpenCL and CUDA
     Boost.Compute (unofficial) STL-like algorithms and data-structures for OpenCL
     Boost.Interprocess
     Boost.Thread
     Boost.Atomic
     Boost.Lockfree
     Boost.MPI
     Boost.Context
     libopenmpi
     libsimdpp
     HPX A general purpose C++ runtime system for parallel and distributed applications of any scale
     SObjectizer A small framework for simplification of development of concurrent and event-driven applications in C++ by using actor and publish-subscribe models. 

 Containers

     Boost.Any
     Boost.Array
     Boost.Bimap
     Boost.Container
     Boost.Fusion
     Boost.Heap
     Boost.Pointer Container
     Boost.Tuple
     Boost.Variant
     cpp-btree -  btree_map, btree_set, btree_multimap, btree_multiset. 

 Serialization

     Boost.Serialization
     libs11n
     sweet_persist
     protobuf
     gSOAP
     C++ XML objects
     yaml-cpp
     YAS (Yet Another Serialization)
     cereal (C++11 serialization) 

 Testing

     Boost.Test
     cppunit
     Google Test
     Catch
     jest - A sane and minimal C++14 unit test framework 

 Benchmarking

     Celero 

 XML

     libxml++
     pugixml
     tinyxml
     tinyxml2 - Another and work in progress of TinyXML.
     Xerces 

 JSON

     jsonme--
     ThorsSerializer
     JsonBox
     jsoncpp
     zoolib
     JOST
     CAJUN
     libjson
     nosjob
     rapidjson
     jsoncons -  jsoncons is a C++ library for the construction of tree structured json values. It also supports an event-based streaming API.
     JSON++
     qjson
     json-cpp
     jansson -  Jansson is C library for encoding, decoding and manipulating JSON data.
     json11 -  json11 is a tiny JSON library for C++11, providing JSON parsing and serialization.
     JSON Voorhees - Killer JSON for C++
     jeayeson - A very sane (header only) C++14 JSON library
     ujson - µjson is a small, C++11, UTF-8, JSON library
     minijson - C++ DOM-less and allocation-free JSON parsing and serialization 

 Web

     libNavajo -  light and powerful http server for web application development (LGPL License)
     libmusicbrainz5
     liblastfm
     libkcddb
     Chromium Embedded
     Wt[src][doc] 

 GPS

     gpsd 

 Databases

     DTL
     libpqxx
     lmdb++ -  C++11 wrapper for the LMDB embedded B+ tree database library.
     mysql++
     ODB - C++ Object-Relational Mapping (ORM)
     QUINCE: QUeries IN C++ Expressions (ORM+EDSL)
     QxOrm - C++ Qt Object-Relational Mapping (ORM)
     SOCI
     sqlpp11 

 Cryptography

     Botan
     gnutls
     openssl
     crypto++
     TomCrypt 

 File metadata

     libkexiv2
     exiv2
     exempi
     rarian 

 Text

 Parse

     PEGTL -  Parsing Expression Grammar Template Library 

 Search

     clucene
     xapian 

 Terminal

     cwidget 

 Configuration

     gconfmm
     libconfig
     Boost.Program_options 

 Embedded languages bindings

     ChaiScript
     ExprTk
     lua
     AngelScript - a scripting language like C++.
     mozjs
     muparser
     PythonQt 

 Embedded/realtime

     QP/C++ -  RTOS kernel, dual GPL
     FreeRTOS C++ Handler -  handler, looper, state machine, CLI, portable
     ETL - Embedded Template Library -  C++ 03, Portable template library tailored for low resource platforms 

 PDF

     HARU
     PoDoFo
     JagPDF 

 Logging

     Log4cpp - A library of C++ classes for flexible logging to files, syslog, IDSA and other destinations (LGPL)
     spdlog - Super fast, header only, C++ logging library
     plog - Portable and simple log for C++ in less than 1000 lines of code (MPL2) 
*** 目前感兴趣的库

  - ACE
  - zeromq
  - zeroc:  
    https://zeroc.com/
  - apache thrift
  - libtins (libpcap, dpkt, impacket, scapy, libcrafter)
    packet crafting and sniffing library
    libpcap最快


** c++ reference
 https://en.wikipedia.org/wiki/Reference_(C%2B%2B)

    - Relationship to pointers
      - It is not possible to refer directly to a reference object after it is defined; any occurrence of its name refers directly to the object it references.
      - Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.
      - References cannot be null, whereas pointers can; every reference refers to some object, although it may or may not be valid. Note that for this reason, containers of references are not allowed.
      - References cannot be uninitialized. Because it is impossible to reinitialize a reference, they must be initialized as soon as they are created. In particular, local and global variables must be initialized where they are defined, and references which are data members of class instances must be initialized in the initializer list of the class's constructor. For example: 
     

*** c++ reference 
 https://isocpp.org/wiki/faq/references

   - Use references when you can, and pointers when you have to.

   - What does it mean that a reference must refer to an object, not a dereferenced null pointer?


** c++11

*** New string literals
 #+BEGIN_EXAMPLE




 C++11 supports three Unicode encodings: UTF-8, UTF-16, and UTF-32. Along with the formerly noted changes to the definition of char, C++11 adds two new character types: char16_t and char32_t. These are designed to store UTF-16 and UTF-32 respectively.

 Creating string literals for each of these encodings can be done thusly:

 u8"I'm a UTF-8 string."
 u"This is a UTF-16 string."
 U"This is a UTF-32 string."

 The type of the first string is the usual const char[]. The type of the second string is const char16_t[] (note lower case 'u' prefix). The type of the third string is const char32_t[] (upper case 'U' prefix).

 When building Unicode string literals, it is often useful to insert Unicode code points directly into the string. To do this, C++11 allows this syntax:

 u8"This is a Unicode Character: \u2018."
 u"This is a bigger Unicode Character: \u2018."
 U"This is a Unicode Character: \U00002018."

 The number after the \u is a hexadecimal number; it does not need the usual 0x prefix. The identifier \u represents a 16-bit Unicode code point; to enter a 32-bit code point, use \U and a 32-bit hexadecimal number. Only valid Unicode code points can be entered. For example, code points on the range U+D800–U+DFFF are forbidden, as they are reserved for surrogate pairs in UTF-16 encodings.

 It is also sometimes useful to avoid escaping strings manually, particularly for using literals of XML files, scripting languages, or regular expressions. C++11 provides a raw string literal:

 R"(The String Data \ Stuff " )"
 R"delimiter(The String Data \ Stuff " )delimiter"

 In the first case, everything between the "( and the )" is part of the string. The " and \ characters do not need to be escaped. In the second case, the "delimiter( starts the string, and it ends only when )delimiter" is reached. The string delimiter can be any string up to 16 characters in length, including the empty string. This string cannot contain spaces, control characters, (, ), or the \ character. Using this delimiter string allows the user to have ) characters within raw string literals. For example, R"delimiter((a-z))delimiter" is equivalent to "(a-z)".[4]

 Raw string literals can be combined with the wide literal or any of the Unicode literal prefixes:

 u8R"XXX(I'm a "raw UTF-8" string.)XXX"
 uR"*(This is a "raw UTF-16" string.)*"
 UR"(This is a "raw UTF-32" string.)"

 #+END_EXAMPLE
